<img width="714" alt="Снимок экрана 2022-08-22 в 17 24 46" src="https://user-images.githubusercontent.com/106627508/185945197-4b38ddec-5133-4c9f-b743-13fcacfa31cb.png">

# Лекция №4 Рекурсия и двумерные


## Двумерные массивы

Первое и главное — как задаются двумерные массивы. По аналогии с одномерными массивами мы
указываем тип данных (например, `string` ), в квадратных скобках ставим запятую как показатель того,
что у нас будет две размерности: первая — строки, вторая — столбцы. Потом даём массиву название
(например, `table` ). После этого пишем `new string` и указываем, какое количество строчек и столбцов
нам нужно.

```
string[,] table = new string[2,3]
```

В первом примере задан массив строк (можно сказать, что это таблица из строк). Но можно задать и
прямоугольную таблицу чисел, которую в математике обычно называют матрицей. В квадратных
скобках также первым числом мы обозначаем количество строк, которые будут в нашем двумерном
массиве, а вторым числом указываем количество столбцов.
```
Int[,] matrix = new int[5,8]
```
## Создание матрицы
---
Начнём с первого примера — напишем таблицу строк. Тип данных `string` вы уже должны были
запомнить. Дальше — `new string`. Указываем, что у нас будет 2 строки и 5 столбцов.

```
string[,] table = new string[2,5];
```
Чтобы обратиться к нужному элементу, указываем имя массива и в квадратных скобках пишем индекс
строки (1) и индекс столбца (2). После этого можем работать как раньше, как будто это обычная
переменная.

```
string[,] table = new string[2,5];
table[1, 2] = "слово";
```
От себя отмечу, что индексы, которые вы будете использовать как для строк, так и для столбцов,
меняются от нуля. То есть, если рассматривать весь наш массив, самый первый элемент будет
`table[0,0]`. Учитывая, что у нас всего две строки, максимальный индекс строки будет `table[1,0]`.


Столбцов у нас пять, поэтому обращаться к ним мы будем так: `table[0,0]` — первый столбик, `table[0,1]`
— второй, `table[0,2]` — третий, `table[0,3]` — четвёртый, `table[0,4]` — пятый. Напоминаю, что для строк
инициализация происходит через константу `Empty`.

```
string[,] table = new string[2,5];
// String.Empty
// table [0,0] table [0,1] table [0,2] table [0,4]
// table [1,0] table [1,1] table [1,2] table [1,4]

table[1, 2] = "слово";
```
Давайте теперь, используя циклы (а здесь нам потребуется цикл в цикле), распечатаем данный массив.
Укажем счётчик rows, количество строк не больше 2. Дальше будет внутренний (вложенный) цикл,
который обозначает количество столбцов (у нас их 5). Здесь мы уже можем сделать распечатывание
элементов массива. Давайте, как и ранее, воспользуемся интерполяцией. Обращаемся к элементам
массива через имя массива. Дальше индекс строки и индекс столбца.

```
string[,] table = new string[2,5];
// String.Empty
// table [0,0] table [0,1] table [0,2] table [0,4]
// table [1,0] table [1,1] table [1,2] table [1,4]

table[1, 2] = "слово";

for (int rows = 0; rows < 2; rows++)
{
    for (int columns = 0; columns < 5; columns++)
    {
        Console.WriteLine($"{table[rows, columns]}");
    }
}
```
Попробуем запустить код в таком виде и посмотрим, что получится. После компиляции видим что-то
непонятное:

<img width="614" alt="Снимок экрана 2022-08-22 в 17 25 53" src="https://user-images.githubusercontent.com/106627508/185945497-1cab676a-0a96-467e-9b38-9be812c9c21c.png">


Чтобы убедиться, что у нас действительно вывелись 10 элементов, сделаем обрамление в виде
минусов или дефисов (кому как больше нравится) и убедимся, что у нас действительно выводятся
строки.

```
string[,] table = new string[2,5];
// String.Empty
// table [0,0] table [0,1] table [0,2] table [0,4]
// table [1,0] table [1,1] table [1,2] table [1,4]

table[1, 2] = "слово";

for (int rows = 0; rows < 2; rows++)
{
    for (int columns = 0; columns < 5; columns++)
    {
        Console.WriteLine($"−{table[rows, columns]}−");
    }
}
```
Как я и говорил, по умолчанию строки у нас инициируются пустой строкой ( `String.Empty` ).

<img width="616" alt="Снимок экрана 2022-08-22 в 17 26 17" src="https://user-images.githubusercontent.com/106627508/185945591-ad855467-d738-4a17-a9c8-877ef102804f.png">


Теперь давайте попробуем сделать примерно то же с числами. Определим двумерный массив, назовём
его `matrix` и укажем для него, например, 3 строки и 4 столбца. Затем поступим аналогично, используя
циклы. Вместо `rows` можно написать `i` (внешний цикл, щёлкающий строки), вместо `columns` — `j`
(внутренний цикл, щёлкающий столбцы). Выводим на экран. Там, где в прошлом примере был дефис
(минус), поставим пробел.

```
int[,] matrix = new int[3, 4];

for (int i = 0; i < 3; i++)
{
    for (int j = 0; j < 4; j++)
    {
        Console.WriteLine($"{matrix[i, j]} ");
    }
}
```
Очистим терминал и посмотрим, что получится.

<img width="617" alt="Снимок экрана 2022-08-22 в 17 26 47" src="https://user-images.githubusercontent.com/106627508/185945723-7266dea8-a3fe-474d-beba-e267288bb408.png">


Работать с двумерными массивами несложно, но есть проблема с выводом. Мы ожидали получить
прямоугольную таблицу чисел, а получили вывод количества элементов. Дело в том, что после вывода
очередного элемента мы переводим курсор в новую позицию. Давайте схитрим и, пока будем
пробегаться по столбцам, будем выводить числа через пробел. А после того, как вывели все элементы
столбцов в текущей строке, принудительно сделаем переход на новую строку. Так добьёмся красивого
вывода матрицы чисел.

```
int[,] matrix = new int[3, 4];

for (int i = 0; i < 3; i++)
{
    for (int j = 0; j < 4; j++)
    {
        Console.Write($"{matrix[i, j]} ");
    }
    Console.WriteLine();
}
```
<img width="607" alt="Снимок экрана 2022-08-22 в 17 27 23" src="https://user-images.githubusercontent.com/106627508/185945872-2b947a49-a41f-468d-b7cb-9a8734d67bcc.png">


У нас получилась матрица или прямоугольная таблица чисел с тремя строками и четырьмя столбцами.

Важно, что 3 и 4 `(int[,] matrix = new int[3, 4])`, которые определены для самого массива,
можно оставить, потому что при инициализации массива вы всегда должны определить, сколько
памяти нужно выделить. А вот в момент, когда вы будете работать, например, в циклах или методах,
можно получить количество строк и другим способом. Для тройки указываем имя массива и новый
функционал `GetLength(0)`. 0 в качестве аргумента означает количество строк. Аналогично и для
четвёрки: пишем имя массива, точку и `GetLength(1).`

```
int[,] matrix = new int[3, 4];
for (int i = 0; i < matrix.GetLength(0); i++)
{
    for (int j = 0; j < matrix.GetLength(1); j++)
    {
        Console.Write($"{matrix[i, j]} ");
    }
Console.WriteLine();
}
```
Убедимся, что получим тот же результат:

Да, увидели всё то же самое.


<img width="607" alt="Снимок экрана 2022-08-22 в 17 27 50" src="https://user-images.githubusercontent.com/106627508/185945964-ecae9669-5233-463f-9003-8c176d88badc.png">


## Заполнение матрицы случайными числами

Теперь попробуем воспользоваться знаниями с предыдущих лекций и опишем метод, который будет
отдельно печатать двумерную матрицу на экран и заполнять её числами. Итак, поехали.

Учитывая тот факт, что мы плюс-минус знаем, как это делается, можем немножко схитрить. Для
текущего кода сделаем обрамление в виде метода. Делаем отступы, чтобы всё было красиво. В
качестве аргумента передаём прямоугольную таблицу чисел. Вместо `matrix` будем передавать
сокращённое название — `matr`. Метод `PrintArray` в качестве аргумента принимает двумерную таблицу чисел и будет печатать её на экран. В качестве аргумента передаём ту матрицу, которая была определена чуть раньше. Чтобы код был более скомпонованным, инициализацию массива перенесём поближе к вызову печати.

```
void PrintArray(int[,] matr)
{
    for (int i = 0; i < matr.GetLength(0); i++)
    {
        for (int j = 0; j < matr.GetLength(1); j++)
        {
            Console.Write($"{matr[i, j]} ");
        }
    Console.WriteLine();
    }
}

int[,] matrix = new int[3, 4];

PrintArray(matrix);
```

Всё хорошо:

<img width="620" alt="Снимок экрана 2022-08-22 в 17 28 19" src="https://user-images.githubusercontent.com/106627508/185946077-34c34e1b-381c-4934-831f-4f39f05b1e41.png">


Теперь опишем дополнительный метод, который будет заполнять нашу матрицу случайными числами.
Здесь всё почти так же, как с одномерными массивами. Для `i` указываем `matr.GetLength(0)` , для `J` —
`matr.GetLength(1)`. Затем обращаемся к конкретному элементу на позиции «итный-житый» и пишем
через использование генератора псевдослучайных чисел. Возьмём полуинтервал от 1 до 10.
Напоминаю, из-за круглых скобок может показаться, что это интервал (как в математике), но у нас получается именно полуинтервал.

Проверим работоспособность нашего метода. Сначала инициализируемся, убедимся, что у нас нули.
Затем сделаем `FillArray` , в качестве аргумента передадим наш массив и снова распечатаем. А чтобы
отделить нули от чисел, перед финальной распечаткой добавим `Console.WriteLine()`.

```
void PrintArray(int[,] matr)
{
    for (int i = 0; i < matr.GetLength(0); i++)
    {
        for (int j = 0; j < matr.GetLength(1); j++)
        {
            Console.Write($"{matr[i, j]} ");
        }
    Console.WriteLine();
   }
}
void FillArray(int[,] matr)
{
    for (int i = 0; i < matr.GetLength(0); i++)
    {
        for (int j = 0; j < matr.GetLength(1); j++)
        {
            matr[i,j] = new Random().Next(1,10);//[1; 10)
        }
    }
}

int[,] matrix = new int[3, 4];
PrintArray(matrix);
FillArray(matrix);
Console.WriteLine();
PrintArray(matrix);
```
Очистим консоль и запустим по новой:

<img width="608" alt="Снимок экрана 2022-08-22 в 17 29 11" src="https://user-images.githubusercontent.com/106627508/185946315-a5c75fc8-5f21-4574-a5a9-63a6c0c8dd48.png">


Были нули, они изменились на числа — всё прекрасно.

# Закрашивание области

Мы попробовали использовать двумерные массивы. Теперь важно запомнить, как и что описывается.
Обязательны:

* тип данных
* квадратные скобки с запятой внутри
* именование массива или идентификатор массива
* оператор присваивания
* обязательное условие new
* тип данных
* количество строк и столбцов в квадратных скобках

`Имя `массива.GetLength(0)` возвращает количество строк в вашем массиве. `Имя массива.GetLength(1)`
— количество столбцов.

Где это можно использовать? Попробуем взять классическую задачу, которую вы решали в модуле
«Математика и информатика», где мы разбирали простые двухцветные картинки. Идея: обычная
прямоугольная таблица чисел, для которых вы можете определить в качестве 0 незакрашенный
пиксель, а в качестве 1 — закрашенный. Это абсолютно прямая отсылка к двумерным числовым
массивам.

<img width="691" alt="Снимок экрана 2022-08-22 в 17 29 57" src="https://user-images.githubusercontent.com/106627508/185946466-9a6c268e-7ba6-4ead-834c-d397e35c1849.png">


Если мы посмотрим только на единицы, увидим палец вверх.

Дальше предлагаю перейти к интересной, но сложной теме — раскраске того, что находится внутри
обрамлённого контура. Технически, в любом графическом редакторе, где вы когда-либо пытались


закрашивать области, вы использовали данный алгоритм (не совсем его, но для объяснения я упрощу).
Покажу работу на простом примере.

Итак, допустим, мы договорились, что у нас есть прямоугольная таблица чисел. В ней 23 строки и 25
столбцов. 0 — незакрашенный пиксель, 1 — закрашенный. Как же закрасить область?

Для этого определяем какую-то точку, которая находится внутри замкнутого контура.

<img width="349" alt="Снимок экрана 2022-08-23 в 09 08 02" src="https://user-images.githubusercontent.com/106627508/186082854-9597a1f4-e0be-47af-b575-3c874805ed4a.png">


После этого нам надо определиться с тем, как мы будем делать обход внутренних точек. Если мы
попали в точку, и эта точка не закрашена, мы её закрашиваем. Далее определяем правило обхода. В
моём случае правило такое — сначала идём вверх, потом влево, потом вниз и вправо. Сейчас всё
покажу детально.

Итак, мы остановились на точке. Дальше смотрим на точку выше.

<img width="275" alt="Снимок экрана 2022-08-23 в 09 08 50" src="https://user-images.githubusercontent.com/106627508/186082972-4512d7c6-6640-4b2e-b241-c26d5405cb31.png">


Если она не закрашена, мы её красим. От неё же смотрим на точку выше. Если она не закрашена,
красим. И так пока не встретим закрашенную точку.

<img width="273" alt="Снимок экрана 2022-08-23 в 09 09 43" src="https://user-images.githubusercontent.com/106627508/186083105-0c805ec5-0d9d-49b6-b75f-15bf88d8b6b7.png">



Дальше по правилу обхода смотрим на точку слева. Если бы её можно было закрасить, мы бы
закрасили. Но в нашем случае снова попадаем на контур. Следующая по порядку точка ниже. Она тоже
закрашена — не красим. Идём в последнее правое направление. Точка не закрашена — красим.

<img width="273" alt="Снимок экрана 2022-08-23 в 09 10 02" src="https://user-images.githubusercontent.com/106627508/186083140-4c0e0b0d-d84e-467b-be85-67ddaa5f7b0f.png">


Затем для текущей точки повторяем все те же действия: идём вверх, если можно, красим, если нельзя
— не красим. Двигаемся дальше по правилу.

<img width="277" alt="Снимок экрана 2022-08-23 в 09 10 21" src="https://user-images.githubusercontent.com/106627508/186083210-6823dd1b-ad27-4305-b632-8cb5645f74de.png">


И так далее. Вся идея закрашивания сводится к простым шагам.

Давайте формально опишем шаги влево, вверх, вправо и вниз. Если мы находимся в текущей точке с
координатами x, y (в данном случае x — позиция строчки, а y — столбца), движение будет выглядеть
таким образом:

<img width="479" alt="Снимок экрана 2022-08-23 в 09 10 56" src="https://user-images.githubusercontent.com/106627508/186083304-7c143ba4-6402-4247-b6d4-56ad54feec4e.png">


Можно двигаться и по диагонали, но тогда придётся проверять дополнительные условия.

<img width="466" alt="Снимок экрана 2022-08-23 в 09 11 17" src="https://user-images.githubusercontent.com/106627508/186083372-d030876d-c4d4-4973-9f65-f9e63469292e.png">


Далее мы должны определить порядок действий. Я договариваюсь ходить сначала вверх, потом
влево, вниз и вправо. Всё ровно так, как на примере с закрашиванием пикселей.

Теперь давайте попробуем написать код, который позволит нам взять картинку и закрасить область
внутри контура.

```
int[,] pic = new int[,]
{
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 },
{0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
};
```
Определим двумерный массив, представляющий наше изображение. Здесь он изначально определён.
Не обязательно указывать количество строк и столбцов, если у вас есть фиксированные данные. Это
можно опустить. Далее я скрою часть кода с нулями и единицами, чтобы она нас не отвлекала. И опишу
метод, который будет выводить картинку. Казалось бы, это тот же двумерный массив, то есть
технически мы можем воспользоваться методом, который был описан ранее. Но есть небольшая
проблема: печататься будет как 0, так и 1. Хочу сделать так, чтобы чуть-чуть более интересный вывод
этого массива производился.

В качестве аргумента вместо matr укажем условный `image`. Дальше всё то же самое, но в момент
вывода проделаем хитрую операцию: будем проверять, если текущий элемент `image[i,j]` совпадает с 0,


будем искусственно печатать пробел. В противном случае мы можем распечатать плюс. `PrintImage` в
качестве аргумента передаём массив, который содержит в себе картинку.

```
void PrintImage(int[,] image)
{
    for (int i = 0; i < image.GetLength(0); i++)
    {
        for (int j = 0; j < image.GetLength(1); j++)
        {
            if(image[i,j] == 0) Console.Write($" ");
            else Console.Write($"+");
        }
        Console.WriteLine();
    }
}
PrintImage(pic);
```
Запустим и посмотрим, что получится.

<img width="613" alt="Снимок экрана 2022-08-23 в 09 12 28" src="https://user-images.githubusercontent.com/106627508/186083590-9a0e055f-5286-4429-9503-3a8180715b2d.png">


Видим палец вверх. Он не совсем красивый, но ничего страшного — это тонкости шрифтов. Технически
в настройках можно указать шрифты с фиксированной шириной для символа. Но нас сейчас это не
особо волнует.

Дальше предлагаю описать метод, который будет закрашивать картинку. По аналогии назовём его
`FillImage`. А в качестве аргумента я укажу позицию строки и пикселя, с которого мы должны будем
начать закраску. Дальше я проверяю условие: если текущий пиксель (pic) с указанной позицией (row,
col) равен нулю (то есть не закрашен), я буду его красить единичкой. А дальше вызову `FillImage`. И
здесь мы определяем правило — что за чем идёт. Сначала поднимаемся на строчку выше (row-1, col),
потом идём влево (row, col-1), потом вниз (row+1, col), потом вправо (row, col+1).


```
void PrintImage(int[,] image)
{
    for (int i = 0; i < image.GetLength(0); i++)
    {
        for (int j = 0; j < image.GetLength(1); j++)
        {
            if(image[i,j] == 0) Console.Write($" ");
            else Console.Write($"+");
        }
        Console.WriteLine();
    }
}
void FillImage(int row, int col)
{
    if (pic[row, col] == 0)
    {
        pic[row, col] = 1;
        FillImage(row - 1, col);
        FillImage(row, col - 1);
        FillImage(row + 1, col);
        FillImage(row, col + 1);
} }
PrintImage(pic);
FillImage(13, 13);
PrintImage(pic);
```
Давайте попробуем посмотреть, к чему нас это приведёт. В качестве случайной точки я указал (13, 13).
Очищу терминал и запущу по новой.

<img width="266" alt="Снимок экрана 2022-08-23 в 09 13 32" src="https://user-images.githubusercontent.com/106627508/186083766-14fb4a55-c1c2-4768-819d-ebe6aa20ff8b.png">


Прошу любить и жаловать — один из алгоритмов, позволяющий закрашивать замкнутые области. У
него есть тонкости: алгоритму нужно много ресурсов. Если вы захотите красить 5К картинку, вас ждут
неприятности. Но на маленьких изображениях всё хорошо — нужно всего 7 строк кода.

## Рекурсия

Здесь для вас открылась новая сущность — ситуация, при которой метод вызывает сам себя. В
математике (программирование — это частный случай математики) есть целая область, которая
занимается подобными случаями — рекуррентные соотношения. В программировании это просто
называется рекурсией.

Что такое рекурсия? Это функция, которая вызывает сама себя. Есть шутка: чтобы понять рекурсию,
нужно понять рекурсию. В ней подчёркивается суть явления. Пример с закраской картинки непростой,
поэтому давайте рассмотрим более тривиальный. Начнём с классической задачи математики —
вычисления факториала. В программировании решим её с помощью рекурсии.

## Вычисление факториала

Что такое факториал? В математике под факториалом понимают произведения чисел от 1 до
заданного и обозначают его восклицательным знаком — «!». Пример факториала: 5! = 5 * 4 * 3 * 2 * 1.
Если бы нам нужно было вычислить 120!, мы бы считали произведение чисел от 1 до 120.

Программисты выяснили, что если мы считаем `5 * на произведение чисел от 1 до 4` , по определению
факториала, это 4!. Таким образом, 5! мы можем представить как `5 * 4!`. 4! — это 4 * 3! и так далее.
Таким образом, мы смогли задать функцию через саму себя. Попробуем написать это кодом.

Определим функцию или метод, который будет принимать число, факториал которого нужно
вычислить. Как вы понимаете, это снова метод, который принимает какой-то аргумент (в частности,
число) и возвращает факториал этого числа.

Определим метод как возвращающий int, и в качестве аргумента принимающий другое целое число.
Далее по определению факториала мы явно укажем: «если мы дошли до единицы (n = 1), мы должны
вернуть 1». Почему? Это определение факториала: 1! = 1. Кстати, отметим, что 0! — это тоже 1.

Итак, если n = 1, возвращаем 1. В противном случае берём екущее значение и умножаем на факториал
предыдущего числа (n - 1). Не забываем, что мы должны явно возвращать значение. То есть, если 1,
возвращаем 1. Если не 1, то `n * Factorial(n-1)` (факториал предыдущего числа).

```
int Factorial(int n)
{
    // 1! = 1
    // 0! = 1
    if(n == 1) return 1;
    else return n * Factorial(n-1);
}
Console.WriteLine(Factorial(3)); // 1 * 2 * 3 = 6
```
Запустим и посмотрим, что получится.

<img width="606" alt="Снимок экрана 2022-08-23 в 09 14 50" src="https://user-images.githubusercontent.com/106627508/186083995-47fa8770-7efb-4094-a91d-3a607932f384.png">



Получаем 6. Дальше, если попытаемся вычислить 5!, получим 120 — всё правильно.

Казалось бы, задачу решили. Но есть проблема: когда мы будем вычислять большие числа (допустим,
40!), в какой-то момент начнём получать отрицательные числа, чего быть не должно.

```
int Factorial(int n)
{
    // 1! = 1
    // 0! = 1
    if(n == 1) return 1;
    else return n * Factorial(n-1);
}
for (int i = 1; i < 40; i++)
{
    Console.WriteLine(Factorial(i));
}
```

<img width="616" alt="Снимок экрана 2022-08-23 в 09 15 31" src="https://user-images.githubusercontent.com/106627508/186084104-f25516be-87ad-4a8e-a6bf-c67c6365b135.png">


Это связано с переполнением типа. Давайте проверим, до какого значения можем посчитать
факториал.


```
int Factorial(int n)
{
    // 1! = 1
    // 0! = 1
    if(n == 1) return 1;
    else return n * Factorial(n-1);
}
for (int i = 1; i < 40; i++)
{
    Console.WriteLine($"{i}! = {Factorial(i)}");
}
```
Очистим и запустим терминал. Всё хорошо до 17!.

<img width="611" alt="Снимок экрана 2022-08-23 в 09 16 04" src="https://user-images.githubusercontent.com/106627508/186084224-0d53af75-bfff-49d5-a723-d0e4bdd4906b.png">


То есть число 17! попросту не вмещается в тип данных `integer` , поэтому появляется первая ваша задача,
связанная с переполнением. Как её решать? Разными способами. Есть тип данных, который такие числа
ещё способен переваривать, — `double`. Давайте integer заменим на double для возвращаемого
результата. Потому что аргументом мы здесь передаём только число до 40.

```
double Factorial(int n)
{
    // 1! = 1
    // 0! = 1
    if(n == 1) return 1;
    else return n * Factorial(n-1);
}
for (int i = 1; i < 40; i++)
{
    Console.WriteLine($"{i}! = {Factorial(i)}");
}
```

<img width="613" alt="Снимок экрана 2022-08-23 в 09 16 39" src="https://user-images.githubusercontent.com/106627508/186084333-332ed482-f080-40be-80c1-0a5a6a9aecf7.png">


Видим нормальные значения. E + 29 означает, что получившееся число нужно умножить на 10^29. Это
достаточно большие числа. Но тип double позволяет их хранить.


## Вычисление чисел Фибоначчи
**Часто спрашивают на собеседованиях**

Мы посмотрели на простой пример использования рекурсии. Думаю, он понятнее, чем закраска
картинки. Есть ли ещё какие-то знакомые вам рекурсивные математические функции? Да, например,
числа Фибоначчи, где каждое следующее число задаётся предыдущим. Давайте попробуем написать
кодом вывод этих чисел.

Для начала укажем определение. Первое число можно указать как f(1)=1, дальше — f(2)=1. Для всех
следующих — то есть, f(n) — мы определяем числа Фибоначчи как f(n-1) + f(n-2). Давайте напишем этот
код.

У нас есть функция, которая будет что-то возвращать (начнём пока с целых чисел). Определяем её
наименование — `Fibonacci`. В качестве аргумента указываем `n`. Если значение n=1 или n=2, возвращаем

1. Иначе мы хотим вернуть Fibonacci(n-1) + Fibonacci(n-2).

```
// f(1) = 1
// f(2) = 1
// f(n) = f(n-1) + f(n-2)
int Fibonacci(int n)
18
{
    if(n == 1 || n == 2) return 1;
    else Fibonacci(n-1) + Fibonacci(n-2);
}
```
Технически всё. Если кого-то смущает наименование, вы знаете, что делать — rename. Можно указать,

например, f. Так функция будет выглядеть компактнее. Но я оставлю полное наименование.

Дальше посмотрим, как будут считаться некоторые числа Фибоначчи. Покажем первые 10.

```
int Fibonacci(int n)
{
    if(n == 1 || n == 2) return 1;
    else return Fibonacci(n-1) + Fibonacci(n-2);
}
for (int i = 1; i < 10; i++)
{
    Console.WriteLine(Fibonacci(i));
}
```
<img width="619" alt="Снимок экрана 2022-08-23 в 09 18 16" src="https://user-images.githubusercontent.com/106627508/186084612-07ff94aa-8c0b-418f-839f-a452e20a5ab1.png">

Получаются те самые числа Фибоначчи — каждое равно сумме двух предыдущих.

Есть тонкий момент. По аналогии с факториалом попробуем посчитать первые 50 чисел Фибоначчи так,
чтобы возвращалось double-значение.

```
double Fibonacci(int n)
{
    if(n == 1 || n == 2) return 1;
    else return Fibonacci(n-1) + Fibonacci(n-2);
}
for (int i = 1; i < 50; i++)
{
    Console.WriteLine(Fibonacci(i));
}
```
Первые числа вылетят в консоль достаточно быстро, а дальше она начнёт работать медленнее.
Попробуем понять, с какого числа начинается проблема.


```
double Fibonacci(int n)
{
    if(n == 1 || n == 2) return 1;
    else return Fibonacci(n-1) + Fibonacci(n-2);
}
for (int i = 1; i < 50; i++)
{
    Console.WriteLine($"f({i}) = {Fibonacci(i)}");
}
```
Начиная с сорокового числа значения выводятся очень медленно. С чем это связано, обязательно
обсудим на семинаре. Но сразу отмечу, что рекурсию можно сделать более шустрой. Можно ли
заменить рекурсию другими конструкциями (в частности, циклом) — да, можно. Именно этим мы
займёмся на семинаре.



## Примеры из жизни

Вы посмотрели математические примеры использования рекурсии, но есть и житейские. Например,
если нужно сделать обход какой-то папки, обычной директории на вашем компьютере. В этом случае у
нас опять всё сводится к рекурсии: чтобы обойти директорию (показать всё, что в этой директории
есть), нам последовательно нужно пройти все папки, которые уже есть в этой папке и показать их
содержимое. То есть, чтобы показать содержимое папок, нужно показать содержимое папок.

Чтобы сделать это на языке C#, нам придется изучить API для работы с файловой системой. Если будет
интересно, это можно сделать на семинарском занятии. Пока помним о том, что рекурсия не только
где-то в математике используется, но и в жизни.

Если я ещё не убедил вас в том, что нам нужны двумерные массивы и рекурсивные методы, предлагаю
рассмотреть идею использования двумерных массивов и методов на примере игры в тетрис. Мы
обязательно детально это разберём на семинарах. Пока что сама идея. Может быть, кто-то из вас
захочет попробовать самостоятельно.



### Тетрис

От себя отмечу, что весь функционал и весь инструментарий, чтобы реализовать эту игру, у вас есть. В
чём основная затея? Обычное поле тетриса — это двумерный массив. В нём есть 0 (свободные клетки) и
1 (клетки, на данном этапе занятые какой-то фигурой). Движение фигуры — смещение 0 и 1
относительно друг друга.

Прямоугольная таблица чисел — это матрица. А матрицы мы можем поворачивать. Соответственно,
поворот фигуры — это поворот матрицы. Обязательно дожидаемся семинаров и разбираем это более


### Заключение

Мы узнали, как задаются двумерные массивы в языке C#. Обязательно запомните запятую, которую
нужно не забывать ставить и в дальнейшем указать количество строк и столбцов. Помним о
функционале Get.Length, который позволяет получить то самое количество строк и столбцов.

Также теперь мы знаем, что массивы на самом то деле сплошь и рядом. Из предыдущей лекции мы
сами узнали, что есть различные виды методов. Здесь мы ещё дополнили знания тем, что есть методы,
которые вызывают сами себя, и они называются рекурсивными. На практике они используются
достаточно часто. На старте бывают нужны не часто, но знать о них и немного попрактиковаться в
написании я настоятельно рекомендую.


